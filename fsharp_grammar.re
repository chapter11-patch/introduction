= F# の文法

本章では、 F# の文法について簡単に解説します。

== 簡単な演算とコメント

まずは、簡単な演算から試してみましょう。

//emlist{
(1 + 2) * 3 // equal 9
//}

スラッシュを続けてふたつ書いた場合は、それ以降が行コメントとして解釈されます。

別の例を試してみましょう。

//emlist{
2 * 3.0 // コンパイルエラー!!
//}

F# は強い静的型付き言語なので、上記コードはコンパイルエラーになります。
どちらかの値を明示的に型変換して型を合わせると、コンパイルできるようになります。
今回は整数型に合わせてみましょう。

//emlist{
2 * (int 3.0) // equal 6
//}

今度は実行できました。

== リテラル

ソースコード内に直接記述する値をリテラルと呼びます。
前節で登場したのはこのうち@<code>{int}型と@<code>{float}型のリテラルです。

ダブルクォートで囲まれた文字列は文字列リテラルです。

//emlist{
"文字列リテラル"
//}

ダブルクォート3つで囲むことにより、改行を含む文字列リテラルを簡単に記述できます。

//emlist{
"""文字列
リテラル"""
//}

F#には他にもいくつかのリテラルが存在しますが、ここでは割愛します。

== 値束縛

さまざまな計算をするにあたり、計算結果をどこかに記憶しておけると便利ですね。
F# では、 @<code>{let} キーワードを使って値と識別子を関連付けられます。
これを、値束縛と呼びます。

//emlist{
let 識別子 : 型名 = 式
//}

演算結果を束縛してみましょう。

//emlist{
let x : int = (1 + 2) * 3 // x equal 9
//}

F#では型推論@<fn>{tapl}という機能により、型名の記述を省略できます。
本書では理解のための補助として型を明示する時以外は、型名の記述を省略します。

//footnote[tapl][オーム社出版 "型システム入門 - プログラミング言語と型の理論"にて詳しく解説されています。]

//emlist{
let x = (1 + 2) * 3
//}

識別子と式は別々の行に分けられます。

//emlist{
let y =
  1 + 2 * 3 - 4
//}

束縛した値が他の束縛にも使えることを確認しましょう。

//emlist{
let x = 1
let y = 2 * 3
let z = x + y - 4 // zの計算にxとyを使用
//}

また、束縛は入れ子にもできます。

//emlist{
let z =
  let x = 1
  let y = 2 * 3
  x + y - 4
// ここではxとyは使えない
//}

F# ではインデントが意味をもつため、各行のインデントは揃えてください。
内部で定義した @<code>{x} と @<code>{y} には、@<code>{z} の式以外からアクセスすることはできません。

単純に識別子と書くだけでは混乱してしまうかもしれないので、以降では束縛により値と関連付けられた識別子は変数と呼ぶことにします。

===[column] let の語源
@<code>{let} というキーワードはあまり聞きなれない方もいるかもしれませんが、
これは数学から来た表記です。
たとえば、

//emlist{
let x = 10, ...
//}

とあると、「x が 10 だとすると、...」という意味になります。
”変数の定義には @<code>{let} を使う”と覚えてしまってもいいですが、
語源を知っていた方が覚えやすいと思うので、頭の片隅にでも置いておくといいでしょう。

===[/column]

===[column] 2 つの let と軽量構文
@<code>{let} により変数が定義できることを本文で説明しましたが、
実は変数の定義は書く場所によって 2 つに分類できます。

 1. モジュールの中などに書いた場合の @<code>{let} による@<strong>{値定義}
 2. 定義の中や関数内などに書いた場合の @<strong>{let 式}

ひとつ目の @<code>{let} による値定義は、本文で説明した次のような構文です。

//emlist{
let 識別子 : 型名 = 式
//}

それに対して、ふたつ目の let 式は本来、次のような構文です。

//emlist{
let 識別子 : 型名 = 式1 in 式2
//}

このように、@<code>{in} に続けて式を書くのが本来の let 式です。
この構文は、式2 の部分で識別子（変数名）が現れた場合にそれを式1 の値に置き換えることを意味しています。

本文で紹介した @<code>{let} を入れ子にしたコードは、z が値定義だとすると本来の構文を使うと次のように書きます。

//emlist{
let z =
  let x = 1 in
  let y = 2 * 3 in
  x + y - 4
//}

F# は @<kw>{軽量構文} という構文をサポートしており、let 式の @<code>{in} を改行とインデントで代用できます。
これによって、上のコードは本文中に載せたような書き方ができるようになり、
@<code>{let} による値定義も let 式と同じ表記で書けることになります。
そのため、「変数を定義する場合は @<code>{let} を使う」と考えてもらってほとんど問題はありません。

===[/column]

F#では日本語を識別子として利用できます。

//emlist{
let 束縛 = 0
//}

さらに、@<code>{``}で括ることによって空白を含めた識別子を定義できます。

//emlist{
let ``これも　束縛`` = 1
//}

@<code>{``}で囲む方法はテストコードを書くときに便利なので、覚えておいて損はないでしょう。

== if 式

F# で条件による分岐を実現する方法のひとつに、if 式があります。

//emlist{
if 条件式 then 条件式がtrueの場合の式
else 条件式がfalseの場合の式
//}

@<code>{then} に続く式と @<code>{else} に続く式は、同じ型である必要があります。
具体的な例で確認してみましょう。

//emlist{
if true then 1 else 0
//}

この式は問題なくコンパイルできます。
しかし、次の式は @<code>{then} に続く式の型が @<code>{int} であるのに対して、@<code>{else} に続く式の型は @<code>{float} なので、両者の型が合わずコンパイルエラーになります。

//emlist{
// コンパイルエラー
if false then 1 else 2.3
//}

条件式には、 @<code>{bool} 型の値である @<code>{true} もしくは @<code>{false} に評価される式を書きます。
よく利用するのは@<code>{=}（等値）や@<code>{<>}（等しくない）でしょう。
また@<code>{>}（より大きい）、 @<code>{<}（未満）、 @<code>{>=}（以上）、 @<code>{<=}（以下）といった比較演算子などが条件式として使えます。

//emlist{
if x < 0 then "not natural number" else "natural number"
//}

== 関数（函数）

"識別子は、値が確定していないパラメータ x と関連付けて定義できる"と仮定すると、x が確定した時点で x に依存する値や式も結果が確定します。
この"パラメータと関連付けられた値や式"を関数（函数） と呼びます。
F# では関数という表記が一般的なため、以降は関数に表記を統一します。

F# での関数定義には、変数でも用いた @<code>{let} キーワードを使います。

//emlist{
let 識別子 1つ以上のパラメータ : 戻り値型 = 式
//}

変数と同様に、戻り値型は式から推論可能なことが多いため、本書では必要と判断した場合を除き、戻り値型を省略します。

実際に関数を定義してみましょう。

//emlist{
let add x y : int = x + y
//}

パラメータは空白区切りで複数指定できます。
この定義から戻り値型を省略すると、次の形になります。

//emlist{
let add x y = x + y
//}

パラメータにも明示的な型の注釈を加えられます。

//emlist{
let add (x : int) (y : int) = x + y
//}

パラメータの型は、型推論可能な場合と型の明示を必要とする場合があります。
しかし、本書で扱うコードは基本的に型推論可能なので、型を明示する必要がある場合の説明は割愛します。

関数を呼び出すには、関数名の後ろに適用する各パラメータを空白区切りで指定します。
@<hd>{簡単な演算とコメント} で、コンパイルエラーを避けるために @<code>{int} による型変換を行いましたが、これは関数呼び出しの一例です。

//emlist{
int 3.0 // 3.0 をパラメータとして int 関数を呼び出す
//}

コメント部分の説明は、"@<code>{int} 関数を @<code>{3.0} に適用する"とも表せます。
本書では関数適用と関数呼び出しを同じ意図で使いますが、以降は関数適用に用語を統一して説明します。

F#では関数も値です。
そのため、関数をパラメータとして渡したり、戻り値として扱えます@<fn>{first-class}。

//footnote[first-class][このふたつの基準の他に、"値を識別子に束縛できる"、"値をデータ構造に格納できる"という基準を満たす値を、ファーストクラスな値と呼びます。]

関数の型は @<kw>{->} で表します。 @<kw>{->} を使うと、パラメータに関数の型を明示できます。

//emlist{
f : パラメータ1の型 -> パラメータ2の型 ... -> 戻り値の型
//}

例として整数値を受け取り整数値を返す f と、整数値 x、 y を受け取って計算結果を返す関数を定義してみましょう。

//emlist{
// f に加算結果を適用して返す関数
let addF (f : int -> int) x y = f (x + y)
//}

addF 関数に、別に定義した関数を適用します。

//emlist{
let square x = x * x
addF square 1 2 // equal 9
//}

関数をパラメータとして受け取ったり、関数を返す関数を高階関数と呼びます。

その場でしか使わない関数値を渡したい場合は、ラムダ式を使います。
ラムダ式は、 @<kw>{fun} と @<kw>{->} で表現します。

//emlist{
fun 一つ以上のパラメータ -> 式
//}

addF にラムダ式を渡してみましょう。

//emlist{
addF (fun x -> x + 3) 1 2 // equal 6
//}

関数の他に、演算子も定義できます。
演算子を定義する場合は、@<code>{let} キーワードを用いる際に演算子を丸括弧で囲みます。

//emlist{
// Haskell形式の不一致の比較演算子を定義
let (/=) x y = x <> y
//}

定義した演算子を使ってみましょう。

//emlist{
1 /= 2 // equal true
//}

また、演算子を丸括弧で囲むと、値の演算子への適用を関数適用と同じ順序で書けます。

//emlist{
(=) 1 2 // equal false
//}

再帰関数は@<kw>{let rec}を使って定義します。

//emlist{
let rec 関数名 1つ以上のパラメータ = 式
//}

次の例では、1から指定した数までの和を再帰関数で定義しています。

//emlist{
let rec sum x =
  if x <= 0 then x
  else x + sum (x - 1)
//}

実際に呼び出してみましょう。

//emlist{
sum 10 // equal 55
sum 0 // equal 0
//}

== モジュール

いくつもの変数や関数を定義したとき、それらをモジュールと呼ばれる1つのグループ単位にまとめて名前をつけることができます。

//emlist{
module モジュール名 =

  ...
//}

具体例として、@<code>{Test}モジュールを定義してみましょう。

//emlist{
module Test =

  let add a b = a + b
//}

F#では慣習的に大文字始まりでモジュール名をつけます。

モジュール名と識別子を@<code>{.}でつなぐことによって、定義したモジュールに置かれている変数や呼び出せます。

//emlist{
Test.add 1 2 // equal 3
//}

モジュール名の省略したい場合には@<kw>{open}を用います。

//emlist{
open Test

add 1 2 // 3
//}

なお、@<kw>{fs}拡張子をもつF#ファイルの先頭でモジュールを定義する場合に限り、@<code>{=}を省略できます。

//emlist{
// .fsファイルの先頭でモジュールを宣言する場合のみこうかける
// これより前にコメント以外のコードを書いたらコンパイルエラー
module Test
//}

モジュールには、変数や定数の他に、後ほど紹介する型の定義も宣言できます。

== unit

入出力のように、本来であれば特定の値を返さないような関数を定義する場合には、@<code>{unit}型という特定の値を持たない型を返すことがほとんどです。
unit方はただ1つの値を持ちます。

//emlist{
() // unit型
//}

実は、私たちはすでにこの値をとある場所で邂逅しています。
それは……Hello Worldコードで登場した@<code>{printfn}関数です！

ここで、前章で出力された@<code>{main}関数を振り返ってみましょう。

//emlist{
let main argv =
  printfn "Hello World from F#!" // () が返る
  0
//}

@<code>{main}関数は@<code>{int}を返す関数ですが、@<code>{0}を返す前に@<code>{unit}を返す@<code>{printfn}関数を実行していました。
これは、最後に値を返す前に@<code>{unit}を返す式をおけることを示しています。
途中で返ってきた@<code>{unit}は捨てても影響はないので捨てられ、最後の値が返り値として返されていたわけです。

== リスト・シーケンス

同一の型をもつ値の集まりを表現する型をコレクションと呼びます。
コレクションのうち、F#では単方向連結リストのことをリストと呼びます。

空のリストは、角括弧を使って表現します。

//emlist{
[] // 空のリスト
//}

要素をひとつ持たせたい場合は、角括弧の間に要素の初期化式を書きます。

//emlist{
[ 要素の初期化式 ]
//}

要素をふたつ以上持たせたい場合は、セミコロン区切りで要素を指定します。

//emlist{
[ 要素の初期化式1; ... ]
//}

それでは実際に、リストを定義してみましょう。

//emlist{
[ 1 + 2 ] // equal [ 3 ]
[ 3; 4; 5 - 6 ] // equal [ 3; 4; -1 ]
//}

要素ごとに改行してインデントを揃えた場合、セミコロンは省略できます。

//emlist{
// [ 1; 1 + 2 ] と同じ結果になる
[ 1
  1 + 2 ]
//}

本書では、要素の初期化式が長くなる場合に改行スタイルを使います。

リストの各要素は同じ型である必要があります。
たとえば、整数と文字列は同じリストの要素として指定できません。

//emlist{
// コンパイルエラー
[ 1; "文字" ]
//}

F# のリストでは、要素の値は変更できません。
常に新たなリストを生成することで、追加や削除、更新を表現します。

リストの先頭に新しい要素を追加するには、 @<code>{::} 演算子を用います。
この場合も、元のリストは変更されず、新しいリストが生成されます。

//emlist{
1 :: [ 2 ] // equal [ 1; 2 ]
//}

@<code>{[1; 2; 3]} は、 @<code>{1 :: 2 :: 3 :: []} の略記です。

シーケンスは呼び出された要素のみが計算されるコレクションです。
そして、シーケンス用の初期化式のことをシーケンス式と呼びます。

//emlist{
// セミコロンで要素を区切る場合
seq { yield 要素の初期化式1; ... }

// インデントで要素を区切る場合
seq {
  yield 要素の初期化式1
  ...
}
//}

要素ではなく、シーケンスを渡したい場合は @<code>{yield!} を使います。

//emlist{
seq {
  yield! シーケンス1
  ...
}
//}

それでは実際に、シーケンス式を使ってシーケンスを定義してみましょう。

//emlist{
seq { 1; 2; 3 } // equal seq [ 1; 2; 3 ]
seq {
  yield 1
  yield! seq { yield 2; yield 3 }
}
// equal seq [ 1; 2; 3 ]
//}

もう少し複雑な例として、フィボナッチ数列をシーケンスで返す関数を定義してみましょう。

//emlist{
let rec fib a b = seq { yield a; yield! fib b (a + b) }
//}

この関数を呼び出すと、無限の長さをもつシーケンスが返されます。

//emlist{
fib 1 1 // seq [ 1; 1; 2; 3; ... ]
//}

== レコード

何らかのデータをグループ化して定義したい場合は、レコードを使います。
レコードは、波括弧の中に識別子名と型のペアをひとつ以上記述して定義します。

//emlist{
type 型名 = {
  識別子1 : 識別子1の型
  識別子2 : 識別子2の型
  ... }
//}

以降は、レコードに属する識別子をフィールドと呼ぶことにします。

例として、分数を定義してみましょう。

//emlist{
type Rational = {
  Numerator : int
  Denominator : int }
//}

定義したレコード（ここでは Rational）の値を作るには、各フィールドの値を設定します。

//emlist{
// 1/2を表す
let x = {
  Numerator = 1
  Denominator = 2 }
//}

フィールドはセミコロンで区切ると、同じ行に連続して書けます。

//emlist{
let x = { Numerator = 1; Denominator = 2 }
//}

フィールドの参照にはドットを使います。

//emlist{
// 分数の加算
let add x y = {
  Numerator = x.Numerator * y.Denominator + y.Numerator * x.Denominator
  Denominator = x.Denominator * y.Denominator }
//}

パラメータ @<code>{x} と @<code>{y} の型を書いていない点に注目してください。
これは、レコードが型推論されることを示しています。

レコードの一部のフィールドの値はコピーし、一部の値は変更して新たな値を作りたい場合には、 @<code>{with} キーワードを使います。

//emlist{
// 分数を2倍する
let twice x = { x with Numerator = x.Numerator * 2 }
//}

この例では、分母はそのままコピーし、分子は2倍して設定するレコードを新たに生成して返しています。

== タプル

2つ以上の任意の型をグループ化したいものの、名前をつけるまでには至らない場合には、タプルを使います。
タプルは、丸括弧とカンマを使って表します。

//emlist{
(要素1, 要素2, ...)
//}

各要素の型は異なる場合もあります。

例として、第一要素にアイテム名、第二要素に個数をもつタプルを作ってみましょう。

//emlist{
// アイテム名が"薬草"で、個数は2
let item = ("薬草", 2)
//}

単にタプルと呼ぶと何要素なのか分からないため、要素数が n のタプルを n-タプル と呼びます。
@<code>{item} は要素数が 2 なので、2-タプルです。

タプルの型を表したい場合は、アスタリスクを使います。

//emlist{
let item : string * int = ("薬草", 2)
//}

2-タプルの場合は、標準で提供されている @<code>{fst} 関数と @<code>{snd} 関数でそれぞれ第一要素、第二要素を取り出せます。

//emlist{
fst item // equal "薬草"
snd item // equal 2
//}

3-タプルや 4-タプルなど、2-タプル以外のタプルでは @<code>{fst} 関数や @<code>{snd} 関数は使えないので注意してください。
@<code>{fst} 関数や @<code>{snd} 関数を使わないタプルの要素の取り出し方もありますが、それについてはパターンマッチで説明します。

== 判別共用体

"いくつかの状態の中のひとつ"を型で表したい場合、判別共用体を使います。

//emlist{
type 型名 =
  | ケース識別子1
  | ケース識別子2
  ...
//}

ある状態をケース識別子で表し、ケース識別子をひとつ以上定義することで型を構成します。

次のコードは、判別共用体を用いて順序付けを表したものです。

//emlist{
type Order =
  | LessThan
  | EqualTo
  | GreaterThan
//}

判別共用体の定義は、一行にまとめることもできます。

//emlist{
type Order = | LessThan | EqualTo | GreaterThan
//}

また、先頭のバーティカルバーは省略できます。

//emlist{
type Order = LessThan | EqualTo | GreaterThan
//}

本書では、一行で記述するか複数行にわけて記述するかは、型定義の見易さに応じて使い分けることにします。
先頭のバーティカルバーは、判別共用体を一行で記述する時のみ省略します。

ケース識別子を指定することで、判別共用体の値を返せます。

//emlist{
// 大小比較
let compare x y =
  if x < y then LessThan
  else
    if x = y then EqualTo
    else GreaterThan
//}

各ケース識別子には、ひとつ以上のフィールドを関連付けられます。
フィールド定義には、 @<code>{of} キーワードを使います。

//emlist{
type 型名 =
  | ケース識別子 of 型
  ...
//}

フィールドを複数持たせたい場合は、アスタリスクで型を区切ります。
アスタリスクで区切ることからタプル型を連想するかもしれませんが、タプルそのものではありません。

//emlist{
type 型名 =
  | ケース識別子 of 型1 * 型2 * ...
//}

フィールドをもつ例として、 特定の図形を表す Shape 型を定義してみましょう。

//emlist{
type Shape =
  | Circle of float
  | Rectangle of float * float
//}

F# 3.1 からは、各フィールドに名前をつけられるようになりました。
フィールド名をつける場合には、コロンを使います。

//emlist{
type Shape =
  | Circle of radius : float
  | Rectangle of width : float * length : float
//}

実際に円や長方形を作ってみましょう。

//emlist{
Circle 2.0 // 半径2の円
Rectangle (3.0, 4.0) // 幅3、長さ4の長方形
//}

ケース識別子によって計算を分岐する方法や、フィールドの値を取り出す方法については、パターンマッチで説明します。

== クラス

クラスはメソッドやプロパティを持てるオブジェクトを表す型です。

//emlist{
type 型名(コンストラクタ引数) =

  束縛

  ...

  member 自己識別子.メソッド名(メソッド引数) =
    ...

  member 自己識別子.プロパティ名 =
    ...
//}

F#では型名の後に続くコンストラクタのことをプライマリコンストラクタと呼びます。
プライマリコンストラクタの引数はそのクラス内で利用できます。

F# ではメソッドとプロパティをメンバーと呼びます。
メソッドとプロパティはどちらを先に定義しても問題ありませんが、@<code>{let} や @<code>{do} による束縛はメンバーよりも先に記述する必要があります。

クラス、束縛、メンバー定義もインデントによってスコープが決まります。

//emlist{
type Square(x: int) =

  // プロパティ
  member __.Area =
    x * x

  // メソッド
  member this.PrintArea() =
    printfn "%d" this.Area
//}

F#の慣習として、メソッドやプロパティ内で自己識別子を使用しない場合は @<code>{__} を自己識別子に使うことが多いです。

== ジェネリック

ジェネリック型@<fn>{generics}のレコードを定義したい場合は、型名の後ろの山括弧の中に型パラメータを記述します。
型パラメータは、カンマ区切りで複数記述できます。

//footnote[generics][他の言語では、多相型や総称型と呼ばれることもあります。]

//emlist{
type Pair<'T, 'U> = { Key : 'T; Value : 'U }
//}

判別共用体やクラスにも型パラメータを記述できます。

//emlist{
type Foo<'T> =
  | Bar of 'T
  | Buz of 'T * 'T

type Pair<'T, 'U>(key: 'T, value: 'V) =
  member __.Key = key
  member __.Value = value
//}

関数やメソッドにも型パラメータを記述できます。

== パターンとパターンマッチ

パターンはデータを構成要素に分解したり、抽出したりするために使う変換規則です。

もっとも簡単な例として、2-タプルの分解を書いてみましょう。

//emlist{
let (x, y) = (1, 2)
//}

@<code>{1}と@<code>{2}で構成されていた2-タプルが分解され、それぞれ@<code>{x}と@<code>{y}という2つの識別子に束縛されます。

もう1つ、例を示します。

//emlist{
let (x, _) = (1, 2)
//}

このコードでは2-タプルの第1要素のみを抽出して（第2要素を捨てて）います。
前節で紹介した@<code>{fst}関数と同じような振る舞いになります。
これもパターンの1つです。

このように、パターンを使えば簡単に構造を分解、値を取得できます。
なお、タプルを分解するパターンのことをタプルパターン、@<code>{_}を用いて任意の値にマッチしその値を捨てるパターンのことををワイルドカードパターンと呼びます。

レコード型もレコードパターンを使って分解できます。

//emlist{
let { Numerator = n; Denominator = d } = { Numerator = 1; Denominator = 2 }
//}

F#ではパターンを用いて計算を分岐する方法として、@<kw>{match}式が用意されています。

//emlist{
match 値 with
| パターン1 -> 式
...
//}

@<kw>{if}式は@<code>{match}式で置き換えられます。

//emlist{
let f b =
  match b with
  | true -> 1
  | false -> 0

f true // equal 1
//}

@<code>{true}や@<code>{false}のような定数値によるパターンを定数パターンと呼びます。

判別共用体は識別子パターンと呼ばれるパターンによって構造を分解できます。
前節で実装した@<code>{Shape}型を識別ごとに分岐させ、面積を計算してみましょう。

//emlist{
let area shape =
  match shape with
  | Circle radius -> radius * radius * 3.14
  | Rectangle(width, height) -> width * height

area (Circle 2.0) // equal 12.56
//}

== 例外

F#では@<kw>{try with}式で例外をキャッチできます。

//emlist{
try
  式
with パターン ->
  式
//}

特に例外の型を指定しない場合は変数パターンを用います。

//emlist{
try
  0 / 0
with e ->
  printfn "例外が投げられました"
  -1
//}

@<kw>{try}で返す値と@<kw>{with}で返す値は同じ型でなる必要があります。

例外を処理する式ではパターンマッチを利用できます。
次に示すのは、型テストパターンで処理を分岐させる例です。

//emlist{
open System

let f x =
  try
    if x = 0 then 0 / x
    else failwaith "test"
  with
    | :? DivideByZeroException as e ->
      -1
    | e -> -2
//}

なお、サンプルコードなので例外を握りつぶしていますが、普段のプログラミングでは例外はきちんと処理しましょう。

例外が投げられた場合にも必ず処理を実行させたいコードが存在する場合は@<kw>{try finally}式を使います。

//emlist{
try
  0 / 0
finally
  printfn "絶対に実行する"
//}

F#では@<kw>{with}と@<kw>{finally}を一気に記述する方法がありません。
この2つを組み合わせたい場合は@<kw>{try finally}式の中に@<kw>{try with}式を記述します。

//emlist{
try
  try
    0 / 0
  with e ->
    printfn "例外が投げられました"
    reraise ()
finally
  printfn "絶対に実行する"
//}

== パイプライン演算子

本章の最後に、F#で忘れてはならない存在、パイプライン演算子を紹介します。

パイプライン演算子は関数と引数の順序を逆にする演算子です。
定義はおよそ次のようになります。

//emlist{
let (|>) x f = f x
//}

やっていることは単純ですが、この演算子を使うと便利なことがあります。
試しに、前節で定義した@<code>{square}関数と@<code>{sum}関数をパイプライン演算子でつないでみます。

//emlist{
let squareSum x =
  x |> square |> sum
//}

計算の流れが非常にわかりやすいとは思いませんか？
オブジェクト指向プログラミングを嗜んでいる方からすれば、なんだメソッドチェインか何を当たり前な……という気持ちになるかもしれません。
しかし、関数プログラミングを主体とするF#でこういった書き方ができるのはとても便利です。

ちなみに、F#には2-tupleと3-tuple用のパイプライン演算子も存在します。

//emlist{
let add x y = x + y

(1, 2)
||> add // equal 3
//}

ところで、F# Software Foundation @<fn>{fssf} という組織のロゴはパイプライン演算子を意識してデザインされているらしいです（要出典）。

//footnote[fssf][http://fsharp.org/]
